#!/usr/bin/perl

use strict;
use warnings;

use YAML;

# zero-tolerance policy
$SIG{__WARN__} = sub { die $_[0] };

my $data = YAML::LoadFile($ARGV[0]);

print <<ENDHEAD;
// THIS FILE IS AUTOMATICALLY GENERATED
// DO NOT EDIT
#include "cmddata.h"
#include "dialect.h"

const cmdinfo cmds[] = {
ENDHEAD

my $idx = 0;

foreach my $key (keys %$data) {
    my $cedocs = cescape($data->{$key}{description} || "UNDOCUMENTED");
    my $argc = scalar @{$data->{$key}{arguments}};
    my $name = $data->{$key}{name};
    my $delegate;
    if ($data->{$key}{pragma}{noparse}) {
        $delegate = undef;
    } elsif ($data->{$key}{pragma}{parser}) {
        $delegate = $data->{$key}{pragma}{parser};
    } else {
        $delegate = qq{new DefaultParser(&caosVM::$key, $idx)};
    }
        
    $data->{$key}{delegate} = $delegate;
    print <<ENDDATA;
    {
        "$name",
        "$cedocs",
        $argc,
    },
ENDDATA
    $idx++;
}

print <<ENDTAIL;
    { NULL, NULL, 0 }
};

void registerAutoDelegates() {
ENDTAIL

foreach my $key (keys %$data) {
    if (defined($data->{$key}{delegate})) {
        if ($data->{$key}{type} eq 'command') {
            print "cmd";
        } else {
            print "exp";
        }
        print "_dialect->delegates[\"", lc($data->{$key}{name}), "\"] = ";
        print $data->{$key}{delegate}, ";\n";
    }
}

print "}\n";

exit 0;

our %cescapes;
BEGIN { %cescapes = (
    "\n" => "\\n",
    "\r" => "\\r",
    "\t" => "\\t",
    "\\" => "\\\\",
    "\"" => "\\\"",
); }

sub cescape {
    my $str = shift;
    my $ces = join "", keys %cescapes;
    $str =~ s/([\Q$ces\E])/$cescapes{$1}/ge;
    return $str;
}
